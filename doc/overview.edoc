@title db_driver
@author cao.xu <cao.xu@rytong.com>
@author deng.lifen <deng.lifen@rytong.com>
@author wang.meigong <wang.meigong@rytong.com>
@copyright 2009-2010 Beijing RYTong Information Technologies, Ltd.
@version {@vsn}

@doc
== Contents ==
{@section Introduction}<br/>
{@section Download}<br/>
{@section Installation}<br/>
{@section Documentation}<br/>
{@section Configuration}<br/>
{@section Getting Started}<br/>
{@section Tests}<br/>
{@section Data Type}<br/>
{@section Notices}<br/>

== Introduction ==

<p>The db_driver is a high performance database driver based on the erlang
    port driver. It is programmed in Erlang and C. It calls C APIs to access 
    database engines.</p>
<p>The db_driver provides the same APIs to operate different
    database engines, supporting MySQL, Oracle and Sybase. It will support 
    DB2 in the future.</p>
<p></p>

== Download ==

See https://github.com/dlfen/erlang-db-driver.

== Installation ==

In the db_driver directory, execute
```
./configure
make
sudo make install
'''

== Documentation ==

In the db_driver directory, execute
```
make doc
'''
to generate document of Erlang APIs.

The Database-Driven Documentation is generated by doxygen. If you installed 
doxygen, you can execute
```
make libdoc
'''
to generate document of C APIs.

See <a href="lib/html/index.html" target="_black">Database-Driven 
Documentation</a>

== Configuration ==

To use db_driver, you need to configure db_driver to set default database 
connection for db_driver to start-up by editing the following Erlang term in your db.conf file:
```
{connect_name, [{driver, mysql},
                {database, "test"},
                {host, "localhost"}, 
                {user, "root"},
                {password, ""},
                {threadlength, 10},
                {poolsize, 8}]}.
'''
connect_name is the name of your connection instance and its type is atom.

The followings are required parameters.

```
driver::atom()          Database type. Supporting mysql, oracle and sybase.
database::string()      Database name.
host::string()          Database host name or IP address.
user:string()           Database user.
password:string()       Database password.
poolsize::integer()     Connection pool size.
threadlength::integer() Thread length.
'''
The followings are optional parameters.

```
port::integer()             Database port. Default value is 3306.
maxthreadlength::integer()  Max thread length. Default value is 1000.
maxqueue::integer()         Max message queue size. Default value is 1000.
'''

You can set many connections in the configuration file and you can get
connection parameters by calling 
db_server:get_db_config(ConfigName, ConfigPath).
The value of ConfigName is connect_name which is a connection name in the 
configuration file, and ConfigPath is the path configuration file. 
db_server:get_db_config(ConfigName) uses the default configuration file path 
(config/db.conf).

== Getting Started ==

1.Starts by normal mode.
```
%% Start db driver.
Pid = db_driver:start().

%% Connection args.
ConnArg = db_server:get_db_config(ConnectName).
%% Or
ConnArg = [{driver, mysql},
           {database, "test"},
           {host, "localhost"}, 
           {user, "root"},
           {password, ""},
           {threadlength, 10},
           {poolsize, 8}].

%% Create a connection.
{ok, ConnPool} = db_driver:connect(ConnArg).

%% Execute sql string.
db_driver:execute_sql(ConnPool, "select version()").

%% Destroy a connect.
db_driver:disconnect(ConnPool),
    
%% Stop db driver.
db_driver:stop(Pid).
'''

2.Starts by server mode.

Started by the server mode, the connection information and fields information
will be storaged in ets table. you may use the default connection or the 
connection has been created to execute the database operation.

```
%% Start db server and db driver.
db_server:start().

%% Initialize default connection, the ConnectName is configured in db.conf.
db_server:init_default(ConnectName).

%% You can use the functions in module db_api to execute the database 
%% operation after starting db server and creating default connection.
db_api:execute_sql("select version()").

%% ConnectName is configured in db.conf.
ConnectArgs = db_server:get_db_config(ConnectName).

%% Create a new connection.
db_server:connect(ConnectName, ConnectArgs).

%% Operate database using the connection just created.
db_api:execute_sql("select version()", [{db_name, ConnectName}]).

%% Stop the db server when you do not need to operate database any more.
db_server:stop().
'''

== Tests ==
See test cases in module db_sample and module db_driver_test.

== Data Type ==

The followings are the mapping of database data type and Erlang data type.

1. MySQL data type.
```
BIT             integer()
TINYINT         integer()
BOOL, BOOLEAN   integer()
SMALLINT        integer()
MEDIUMINT       integer()
INT             integer()
INTEGER         integer()
BIGINT          integer()
FLOAT           float()
DOUBLE          float()
FLOAT           float()
DECIMAL         float()
DATE            {date, {Year::integer(), Month::integer(), Day::integer()}}
DATETIME        {datetime,
                    {{Year::integer(), Month::integer(), Day::integer()},
                     {Hour::integer(), Minute::integer(), Second::integer()}}}
TIMESTAMP       {datetime,
                    {{Year::integer(), Month::integer(), Day::integer()},
                     {Hour::integer(), Minute::integer(), Second::integer()}}}
TIME            {time, 
                    {Hour::integer(), Minute::integer(), Second::integer()}}
YEAR            integer()
CHAR            integer()
VARCHAR         string()
BINARY          string()
VARBINARY       string()
TINYBLOB        binary()
TINYTEXT        string()
BLOB            binary()
TEXT            string()
MEDIUMBLOB      binary()
MEDIUMTEXT      string()
LONGBLOB        binary()
LONGTEXT        string()
'''

2. Oracle data type.
```
STRING          string()
NUMBER          number()
DATE            {datetime,
                    {{Year::integer(), Month::integer(), Day::integer()},
                     {Hour::integer(), Minute::integer(), Second::integer()}}}
TIMESTAMP       {timestamp, 
                    {{Year::integer(), Month::integer(), Day::integer()},
                     {Hour::integer(),
                      Minute::integer(),
                      Second::integer(),
                      Microseconds::integer()},      
                     {TimeZoneOffsetInHours::integer(), 
                      TimeZoneOffsetInMinutes::integer()}}}
TIMESTAMP_Z     {timestamp,
                    {{Year::integer(), Month::integer(), Day::integer()},
                     {Hour::integer(),
                      Minute::integer(),
                      Second::integer(),
                      Microseconds::integer()},
                     {TimeZoneOffsetInHours::integer(), 
                      TimeZoneOffsetInMinutes::integer()}}}
TIMESTAMP_LZ    {timestamp,
                    {{Year::integer(), Month::integer(), Day::integer()},
                     {Hour::integer(),
                      Minute::integer(),
                      Second::integer(), 
                      Microseconds::integer()},
                     {TimeZoneOffsetInHours::integer(), 
                      TimeZoneOffsetInMinutes::integer()}}}
BINARY          binary()
CLOB            string()
NCLOB           string()
BLOB            binary()
INTERVAL_YM     {interval_ym, {Year::integer(), Month::integer()}}}  
INTERVAL_DS     {interval_ds, 
                    {Day::integer(),
                     Hour::integer(),
                     Minute::integer(),
                     Second::integer(),
                     FractionalSecondComponent::integer()}}
'''

3. Sybase data type.
```
VARBINARY       binary()
BIT             integer()
CHAR            string()
VARCHAR         string()
UNICHAR         list()
UNIVARCHAR      list()
DATE            {date, {Year::integer(), Month::integer(), Day::integer()}}
TIME            {time,
                    {Hour::integer(),
                     Minute::integer(),
                     Second::integer(),
                     Millisecond::integer()}}
DATETIME        {datetime,
                    {{Year::integer(), Month::integer(), Day::integer()},
                     {Hour::integer(),
                      Minute::integer(),
                      Second::integer(),
                      Millisecond::integer()}}}
SMALLDATETIME   {smalldatetime,         
                    {{Year::integer(), Month::integer(), Day::integer()},
                     {Hour::integer(), Minute::integer()}}}
TINYINT         integer()
SMALLINT        integer()
INT             integer()
BIGINT          integer()
DECIMAL         {number, string()}
NUMERIC         {number, string()}
FLOAT           float()
REAL            float()
MONEY           {number, string()}
SMALLMONEY      float()
'''

== Notices ==
1. Oracle prepare statement.

    The sql of prepare is like "select ?,? from user", but the sql in Oracle 
    is like "select :1,:2 from user".
    You can consistently use two methods in module db_api, but you can only 
    use the second method in module db_driver.
